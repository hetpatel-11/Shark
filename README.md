# Shark

Shark is a production-oriented autonomous founder and operator that runs continuously inside Daytona. It uses Claude Agent SDK as the control brain, chooses from a toolset at runtime, and keeps building and operating an AI-native startup with long-term memory, durable state, and human steering through Slack plus a web UI.

## Core principles

- All execution happens inside Daytona in production. No local control plane is required.
- Claude Agent SDK is the single decision-maker. Tools remain loosely coupled and selectable at runtime.
- The system is autonomous by default, but it must notify the operator of important milestones and accept interrupts immediately.
- The agent can deploy and post publicly without approval, but it cannot spend money or create paid commitments without an explicit operator approval.
- Startup selection happens after market research. Once a startup is chosen, Shark commits to it and iterates instead of thrashing across ideas.

## Planned stack

- Brain: Anthropic Claude via Claude Agent SDK
- Long-term memory: Supermemory
- Realtime state and operator control: Convex
- Browser execution and research: Browser Use
- Authenticated inbox and outbound mail: AgentMail
- Sandboxed execution: Daytona
- Deployment: Vercel
- Operator messaging: Slack
- Operator UI: Vercel-hosted web app backed by Convex

## Repo layout

- `ARCHITECTURE.md`: production system contract and runtime design
- `IMPLEMENTATION_PLAN.md`: staged build plan
- `PROMPT_plan.md`: planning-mode prompt for Ralph-style iterations
- `PROMPT_build.md`: implementation-mode prompt for Ralph-style iterations
- `PROMPT_operate.md`: operations-mode prompt for post-launch iteration
- `AGENTS.md`: repo-specific execution rules and validation commands
- `src/`: TypeScript contracts and loop scaffolding

## Current status

This repository now includes a runnable Shark control plane:

- a persistent autonomous loop
- real HTTP adapters for Anthropic, Supermemory, Browser Use, AgentMail, Slack, and Vercel
- command execution inside the current runtime for Daytona-style sandbox work
- a local control dashboard and JSON API
- artifact persistence under `.shark/workspace`

## Run it

1. Copy `.env.example` to `.env.local` or export the variables in your shell.
2. Add the provider credentials you want Shark to use.
3. For a remote-first launch, run `npm run deploy:daytona` to build and start Shark inside a Daytona sandbox.
4. For direct runtime testing only, use `npm run dev` or `npm run build && npm start`.

## Remote deployment

`npm run deploy:daytona` will:

- create a fresh Daytona sandbox
- upload the Shark source tree
- run `npm install` and `npm run build` inside Daytona
- start the control plane remotely
- print a Daytona preview URL for the live dashboard

This is the intended production-style path. The long-running worker should live in Daytona, not on the operatorâ€™s machine.

## HTTP endpoints

- `GET /`: operator dashboard
- `GET /healthz`: health probe
- `GET /api/state`: current run snapshot
- `POST /api/run-once`: execute one loop iteration
- `POST /api/start`: start continuous execution
- `POST /api/stop`: stop continuous execution
- `POST /api/command`: queue an operator interrupt with JSON `{ "text": "..." }`

## Implementation note

The runtime is end-to-end functional today with file-backed durable state. Convex-specific generated APIs are not checked into this repository because they depend on your app deployment and are generated by `npx convex dev`. The current service is structured so Convex can replace the file store cleanly.
